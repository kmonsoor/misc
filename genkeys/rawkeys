#!/usr/bin/env python
#
# Read a seed from stdin and output MPK (Master Public Key), and key/address pairs.
# Input one seed per line hex (32 chars).
#
# Outputs the SEED and MPK for restoring to Electrum.
# SEED for full wallet, MPK for watch only wallet.
# eg.
#     hexdump -v -e '/1 "%02X"' -n 16 /dev/urandom | genkeys
# or
#     echo "1279666de665e6c662d2f45538842acd" | genkeys
#
# Optionally given an index and count it also will 
# generate key/address pairs. Arguments are,
# 
#    rawkeys [count] [chg] [start-index]
#
# Where:
#    count is number of key/addr pairs to output, default none
#    chg is number of change key/addr pairs to append
#    start-index, defaults to 0 
#

import sys, hashlib

# sha256 support (adapted for python 2.7 from slowsha)

class sha256(object):
    _h0, _h1, _h2, _h3, _h4, _h5, _h6, _h7 = (
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 )

    def __init__(self, message):
        message = bytearray(message)
        length = bin(len(message) * 8)[2:].rjust(64, "0")
        while len(message) > 64:
            self._handle(''.join(bin(i)[2:].rjust(8, "0")
                for i in message[:64]))
            message = message[64:]
        message = ''.join(bin(i)[2:].rjust(8, "0") for i in message) + "1"
        message += "0" * ((448 - len(message) % 512) % 512) + length
        for i in range(len(message) // 512):
            self._handle(message[i * 512:i * 512 + 512])

    def _handle(self, chunk):

        rrot = lambda x, n: (x >> n) | (x << (32 - n))
        w = []

        k = [
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
            0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
            0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
            0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
            0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
            0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
            0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
            0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
            0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]

        for j in range(len(chunk) // 32):
            w.append(int(chunk[j * 32:j * 32 + 32], 2))

        for i in range(16, 64):
            s0 = rrot(w[i - 15], 7) ^ rrot(w[i - 15], 18) ^ (w[i - 15] >> 3)
            s1 = rrot(w[i - 2], 17) ^ rrot(w[i - 2], 19) ^ (w[i - 2] >> 10)
            w.append((w[i - 16] + s0 + w[i - 7] + s1) & 0xffffffff)

        a = self._h0
        b = self._h1
        c = self._h2
        d = self._h3
        e = self._h4
        f = self._h5
        g = self._h6
        h = self._h7

        for i in range(64):
            s0 = rrot(a, 2) ^ rrot(a, 13) ^ rrot(a, 22)
            maj = (a & b) ^ (a & c) ^ (b & c)
            t2 = s0 + maj
            s1 = rrot(e, 6) ^ rrot(e, 11) ^ rrot(e, 25)
            ch = (e & f) ^ ((~ e) & g)
            t1 = h + s1 + ch + k[i] + w[i]

            h = g
            g = f
            f = e
            e = (d + t1) & 0xffffffff
            d = c
            c = b
            b = a
            a = (t1 + t2) & 0xffffffff

        self._h0 = (self._h0 + a) & 0xffffffff
        self._h1 = (self._h1 + b) & 0xffffffff
        self._h2 = (self._h2 + c) & 0xffffffff
        self._h3 = (self._h3 + d) & 0xffffffff
        self._h4 = (self._h4 + e) & 0xffffffff
        self._h5 = (self._h5 + f) & 0xffffffff
        self._h6 = (self._h6 + g) & 0xffffffff
        self._h7 = (self._h7 + h) & 0xffffffff

    def digest(self):
        return ''.join(hex(i)[2:-1].rjust(8, "0") for i in (self._h0,self._h1,self._h2,self._h3,self._h4,self._h5,self._h6,self._h7)).decode('hex')

# the secp256k1 curve parameters 
_p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL
_r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L
_b = 0x0000000000000000000000000000000000000000000000000000000000000007L
_a = 0x0000000000000000000000000000000000000000000000000000000000000000L
_Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L
_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L

# EC math support (adapted from python-ecdsa)

def InvMod(a, m):
    if a < 0 or m <= a: a = a % m
    
    c, d = a, m
    uc, vc, ud, vd = 1, 0, 0, 1
    while c != 0:
        q, c, d = divmod( d, c ) + ( c, )
        uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc
        
    assert d == 1
    if ud > 0: return ud
    else: return ud + m
    
def ptDouble( (x,y) ):
    if (x,y) == (None,None): 
        return (None, None)
        
    l = ( ( 3 * x * x + _a ) * InvMod( 2 * y, _p ) ) % _p
    x3 = ( l * l - 2 * x ) % _p
    y3 = ( l * ( x - x3 ) - y ) % _p
    
    return (x3,y3)
 
def ptAdd( (x1,y1), (x2,y2) ):

    if (x2,y2) == (None, None): return (x1,y1)
    if (x1,y1) == (None, None): return (x2,y2)

    if x1 == x2:
        if ( y1 + y2 ) % _p == 0:
            return (None, None)
        else:
            return ptDouble((x1,y1))

    l = ( ( y2 - y1 ) * InvMod( x2 - x1, _p ) ) % _p

    x3 = ( l * l - x1 - x2 ) % _p
    y3 = ( l * ( x1 - x3 ) - y1 ) % _p

    return (x3, y3)
   
def ptMul( (x,y), z ):

    def leftmost_bit( x ):
        assert x > 0
        result = 1
        while result <= x: result = 2 * result
        return result // 2

    e = z % _r
    if e == 0: return (None, None)
    if (x,y) == (None, None): return (None, None)
    assert e > 0

    e3 = 3 * e
    i = leftmost_bit( e3 ) // 2
    (xr,yr) = (x,y)

    while i > 1:
      (xr,yr) = ptDouble((xr,yr))
      if ( e3 & i ) != 0 and ( e & i ) == 0:
          (xr,yr) = ptAdd((xr,yr), (x,y))
      if ( e3 & i ) == 0 and ( e & i ) != 0: 
          (xr,yr) = ptAdd((xr,yr), (x,-y))
      i = i // 2

    return (xr,yr)

# support functions - formatting and conversion 

def b58encode(addr):
    alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    long_value = 0L
    for (i, c) in enumerate(addr[::-1]):
        long_value += (256**i) * ord(c)

    result = ''
    while long_value >= 58:
        div, mod = divmod(long_value, 58)
        result = alphabet[mod] + result
        long_value = div
    result = alphabet[long_value] + result

    nPad = 0
    for c in addr:
        if c == '\0': nPad += 1
        else: break

    return (alphabet[0]*nPad) + result

def public_key_to_address(public_key):
    md = hashlib.new('ripemd160')
    md.update(sha256( public_key.decode('hex') ).digest())
    vh160 = chr(0) + md.digest()
    hash = sha256(sha256( vh160 ).digest()).digest()
    return b58encode( vh160 + hash[0:4] )
         
def private_key_to_wif(priv_key):
    hash = sha256(sha256( priv_key ).digest()).digest()
    return b58encode( priv_key + hash[0:4] )
    
def seq(i, chg, mpk):
    return int( sha256(sha256( "%d:%d:" % (i, chg) + mpk ).digest()).digest().encode('hex'), 16 )

# read seeds, do math, output mpk and key pairs
for seed in sys.stdin:
    secexp = seed = seed[:32].replace(' ', '')
    for i in range(100000):
        secexp = hashlib.sha256( secexp + seed ).digest()
    secexp = int(secexp.encode('hex'), 16)
    mpk = (x,y) = ptMul((_Gx,_Gy), secexp)
    mpk_str = ('%064x' % x + '%064x' % y).decode('hex')
    print "\nSeed:%s\nMPK:%s\n" % (seed, mpk_str.encode('hex'))
    
    argc = len(sys.argv)
    if argc > 1:
        count = 5 if argc < 2 else int(sys.argv[1])
        chg = 0 if argc < 3 else int(sys.argv[2])
        index = 0 if argc < 4 else int(sys.argv[3])

        for (i,c) in [(n,0) for n in range(index,index+count)]+[(n,1) for n in range(index,index+chg)]:
            priv_key = ('%064x' %  ((secexp + seq(i, c, mpk_str)) % _r) ).decode('hex')
            (x,y) = ptAdd(mpk, ptMul((_Gx,_Gy), seq(i, c, mpk_str)))
            pub_key_str = '04' + ('%064x' % x) + ('%064x' % y)
            print "m/%d/%d %s,%s" % (c,i, private_key_to_wif( chr((0+128)&255) + priv_key ), public_key_to_address( pub_key_str ))

        
        
